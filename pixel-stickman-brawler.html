<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>像素火柴人：街头乱斗</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0d0d0d;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
        }

        #gameContainer {
            position: relative;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 4px solid #29adff;
            box-shadow: 0 0 40px rgba(41, 173, 255, 0.4);
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #5f574f;
            font-size: 8px;
            text-align: center;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="controls">
        移动: WASD/方向键 | 攻击: J/Z | 跳跃: K/X | 冲刺: 空格 | 必杀: L/C | 暂停: ESC
    </div>

    <script>
    // ============================================
    // 像素火柴人：街头乱斗 - 游戏主代码
    // ============================================

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // 游戏配置
    const GAME_WIDTH = 800;
    const GAME_HEIGHT = 450;
    const SCALE = 2; // 像素缩放

    canvas.width = GAME_WIDTH;
    canvas.height = GAME_HEIGHT;
    canvas.style.width = `${GAME_WIDTH * SCALE}px`;
    canvas.style.height = `${GAME_HEIGHT * SCALE}px`;

    // 禁用平滑处理
    ctx.imageSmoothingEnabled = false;

    // 颜色调色板
    const COLORS = {
        // 主角
        hero: { body: '#ff9e22', outline: '#1a1c2c', accent: '#ffffff' },
        // 敌人
        grunt: { body: '#ff0044', outline: '#1a1c2c', accent: '#ffffff' },
        ranger: { body: '#00e436', outline: '#1a1c2c', accent: '#ffffff' },
        brute: { body: '#9d4edd', outline: '#1a1c2c', accent: '#ffffff' },
        boss: { body: '#ffd700', outline: '#1a1c2c', accent: '#ff0000' },
        // 场景
        ground: { light: '#3d3d3d', dark: '#2a2a2a' },
        // UI
        ui: { health: '#00e436', energy: '#29adff', damage: '#ff0044', combo: '#ffd700' }
    };

    // 游戏状态
    const GameState = {
        MENU: 'MENU',
        PLAYING: 'PLAYING',
        PAUSED: 'PAUSED',
        GAME_OVER: 'GAME_OVER',
        VICTORY: 'VICTORY',
        WAVE_TRANSITION: 'WAVE_TRANSITION'
    };

    let gameState = GameState.MENU;
    let currentLevel = 1;
    let currentWave = 1;
    let score = 0;
    let combo = 0;
    let comboTimer = 0;
    let screenShake = { x: 0, y: 0, intensity: 0 };
    let hitStop = 0;
    let transitionAlpha = 0;
    let transitionState = 'in';

    // 输入状态
    const keys = {};
    const keysPressed = {};

    // 音频上下文
    let audioCtx = null;

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
    }

    // 音效生成器
    function playSound(type) {
        if (!audioCtx) return;

        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        switch(type) {
            case 'hit':
                oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
                break;
            case 'attack':
                oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.05);
                gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.05);
                break;
            case 'jump':
                oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.15);
                break;
            case 'skill':
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(100, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.25, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.3);
                break;
            case 'enemyDeath':
                oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.2);
                break;
            case 'wave':
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                oscillator.frequency.setValueAtTime(550, audioCtx.currentTime + 0.1);
                oscillator.frequency.setValueAtTime(660, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.3);
                break;
        }
    }

    // ============================================
    // 粒子系统
    // ============================================
    class Particle {
        constructor(x, y, vx, vy, color, size, life) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.vy = vy;
            this.color = color;
            this.size = size;
            this.life = life;
            this.maxLife = life;
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += 0.3;
            this.life--;
            return this.life > 0;
        }

        draw() {
            const alpha = this.life / this.maxLife;
            ctx.fillStyle = this.color;
            ctx.globalAlpha = alpha;
            ctx.fillRect(Math.floor(this.x), Math.floor(this.y), this.size, this.size);
            ctx.globalAlpha = 1;
        }
    }

    let particles = [];

    function spawnParticles(x, y, color, count, spread) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * spread + 2;
            const vx = Math.cos(angle) * speed;
            const vy = Math.sin(angle) * speed - 3;
            const size = Math.random() * 4 + 2;
            particles.push(new Particle(x, y, vx, vy, color, size, 30));
        }
    }

    // ============================================
    // 伤害数字
    // ============================================
    class DamageNumber {
        constructor(x, y, damage, isCombo) {
            this.x = x;
            this.y = y;
            this.damage = damage;
            this.vy = -2;
            this.life = 60;
            this.isCombo = isCombo;
        }

        update() {
            this.y += this.vy;
            this.vy *= 0.95;
            this.life--;
            return this.life > 0;
        }

        draw() {
            const alpha = Math.min(1, this.life / 20);
            const scale = this.isCombo ? 1.5 : 1;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = this.isCombo ? COLORS.ui.combo : COLORS.ui.damage;
            ctx.font = `${10 * scale}px "Press Start 2P"`;
            ctx.textAlign = 'center';
            ctx.fillText(this.damage, this.x, this.y);
            ctx.globalAlpha = 1;
        }
    }

    let damageNumbers = [];

    // ============================================
    // 实体基类
    // ============================================
    class Entity {
        constructor(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.vx = 0;
            this.vy = 0;
            this.direction = 1;
            this.state = 'IDLE';
            this.stateFrame = 0;
            this.health = 100;
            this.maxHealth = 100;
            this.invincible = 0;
            this.hurtTimer = 0;
            this.onGround = false;
            this.groundY = GAME_HEIGHT - 80;
        }

        getHurtbox() {
            return {
                x: this.x + 8,
                y: this.y + 8,
                width: this.width - 16,
                height: this.height - 8
            };
        }

        getAttackBox() {
            return null;
        }

        applyGravity() {
            this.vy += 0.8;
            if (this.y + this.height >= this.groundY) {
                this.y = this.groundY - this.height;
                this.vy = 0;
                this.onGround = true;
            } else {
                this.onGround = false;
            }
        }

        update() {
            if (this.invincible > 0) this.invincible--;
            if (this.hurtTimer > 0) this.hurtTimer--;
            this.stateFrame++;
        }

        takeDamage(damage, knockbackX, knockbackY) {
            if (this.invincible > 0) return false;

            this.health -= damage;
            this.invincible = 15;
            this.hurtTimer = 10;
            this.vx = knockbackX;
            this.vy = knockbackY;

            if (this.health <= 0) {
                this.die();
            }

            return true;
        }

        die() {
            // 子类实现
        }

        drawPixel(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
        }

        drawStickman(x, y, color, outlineColor, accentColor, pose) {
            const scale = 3;
            const cx = x + this.width / 2;

            ctx.fillStyle = outlineColor;

            switch(pose) {
                case 'IDLE':
                    // 头
                    ctx.fillRect(cx - 6, y, 12, 10);
                    // 身体
                    ctx.fillRect(cx - 3, y + 10, 6, 16);
                    // 左手
                    ctx.fillRect(cx - 10, y + 12, 7, 4);
                    ctx.fillRect(cx - 10, y + 16, 4, 6);
                    // 右手
                    ctx.fillRect(cx + 3, y + 12, 7, 4);
                    ctx.fillRect(cx + 6, y + 16, 4, 6);
                    // 左腿
                    ctx.fillRect(cx - 6, y + 26, 4, 8);
                    ctx.fillRect(cx - 7, y + 34, 5, 4);
                    // 右腿
                    ctx.fillRect(cx + 2, y + 26, 4, 8);
                    ctx.fillRect(cx + 2, y + 34, 5, 4);
                    break;

                case 'RUN':
                    const runOffset = Math.sin(this.stateFrame * 0.5) * 4;
                    // 头
                    ctx.fillRect(cx - 6, y + runOffset * 0.3, 12, 10);
                    // 身体前倾
                    ctx.fillRect(cx - 4, y + 10 + runOffset * 0.3, 6, 14);
                    ctx.fillRect(cx - 1, y + 24 + runOffset * 0.3, 4, 4);
                    // 手臂摆动
                    const armOffset = Math.sin(this.stateFrame * 0.8) * 6;
                    ctx.fillRect(cx - 8 + armOffset, y + 12, 6, 4);
                    ctx.fillRect(cx - 10 + armOffset, y + 16, 4, 5);
                    ctx.fillRect(cx + 2 - armOffset, y + 12, 6, 4);
                    ctx.fillRect(cx + 6 - armOffset, y + 16, 4, 5);
                    // 腿
                    const legOffset = Math.sin(this.stateFrame * 0.8) * 8;
                    ctx.fillRect(cx - 6 - legOffset * 0.5, y + 24, 5, 8);
                    ctx.fillRect(cx - 8 - legOffset, y + 32, 5, 4);
                    ctx.fillRect(cx + 1 + legOffset * 0.5, y + 24, 5, 8);
                    ctx.fillRect(cx + 3 + legOffset, y + 32, 5, 4);
                    break;

                case 'JUMP':
                    // 头
                    ctx.fillRect(cx - 6, y - 4, 12, 10);
                    // 身体蜷缩
                    ctx.fillRect(cx - 5, y + 6, 8, 12);
                    // 手臂举起
                    ctx.fillRect(cx - 14, y, 8, 4);
                    ctx.fillRect(cx - 14, y - 4, 4, 6);
                    ctx.fillRect(cx + 6, y, 8, 4);
                    ctx.fillRect(cx + 10, y - 4, 4, 6);
                    // 腿蜷缩
                    ctx.fillRect(cx - 8, y + 18, 6, 6);
                    ctx.fillRect(cx + 2, y + 18, 6, 6);
                    break;

                case 'FALL':
                    // 头
                    ctx.fillRect(cx - 6, y - 8, 12, 10);
                    // 身体伸展
                    ctx.fillRect(cx - 4, y + 2, 8, 14);
                    // 手臂伸展
                    ctx.fillRect(cx - 16, y + 4, 12, 4);
                    ctx.fillRect(cx + 4, y + 4, 12, 4);
                    // 腿伸展
                    ctx.fillRect(cx - 8, y + 16, 5, 10);
                    ctx.fillRect(cx + 3, y + 16, 5, 10);
                    break;

                case 'ATTACK1':
                    // 头
                    ctx.fillRect(cx - 6, y, 12, 10);
                    // 身体
                    ctx.fillRect(cx - 4, y + 10, 6, 14);
                    // 出拳手臂
                    ctx.fillRect(cx + 5, y + 12, 10, 5);
                    ctx.fillRect(cx + 14, y + 11, 5, 7);
                    // 另一手臂
                    ctx.fillRect(cx - 10, y + 14, 6, 4);
                    // 腿
                    ctx.fillRect(cx - 6, y + 24, 5, 8);
                    ctx.fillRect(cx + 1, y + 24, 5, 8);
                    break;

                case 'ATTACK2':
                    // 头
                    ctx.fillRect(cx - 6, y, 12, 10);
                    // 身体
                    ctx.fillRect(cx - 4, y + 10, 6, 14);
                    // 另一只手出拳
                    ctx.fillRect(cx - 14, y + 11, 10, 5);
                    ctx.fillRect(cx - 16, y + 10, 5, 7);
                    // 腿
                    ctx.fillRect(cx - 7, y + 24, 5, 8);
                    ctx.fillRect(cx + 2, y + 24, 5, 8);
                    break;

                case 'ATTACK3':
                    // 头
                    ctx.fillRect(cx - 6, y - 2, 12, 10);
                    // 身体旋转
                    ctx.fillRect(cx - 5, y + 8, 8, 12);
                    // 腿踢
                    ctx.fillRect(cx + 8, y + 10, 12, 5);
                    ctx.fillRect(cx + 18, y + 8, 5, 7);
                    // 手臂
                    ctx.fillRect(cx - 14, y + 14, 10, 4);
                    ctx.fillRect(cx - 16, y + 18, 4, 5);
                    break;

                case 'DASH':
                    // 残影效果 - 只画轮廓
                    ctx.globalAlpha = 0.5;
                    ctx.fillRect(cx - 8, y + 2, 12, 8);
                    ctx.fillRect(cx - 5, y + 10, 6, 12);
                    ctx.fillRect(cx - 14, y + 14, 10, 4);
                    ctx.fillRect(cx + 4, y + 14, 10, 4);
                    ctx.fillRect(cx - 10, y + 22, 6, 8);
                    ctx.fillRect(cx + 4, y + 22, 6, 8);
                    ctx.globalAlpha = 1;
                    // 主体
                    ctx.fillRect(cx - 6, y, 12, 10);
                    ctx.fillRect(cx - 3, y + 10, 6, 14);
                    ctx.fillRect(cx - 10, y + 14, 8, 4);
                    ctx.fillRect(cx + 2, y + 14, 8, 4);
                    ctx.fillRect(cx - 8, y + 24, 5, 8);
                    ctx.fillRect(cx + 3, y + 24, 5, 8);
                    break;

                case 'SKILL':
                    // 蓄力姿势
                    ctx.fillRect(cx - 8, y - 4, 14, 12);
                    ctx.fillRect(cx - 6, y + 8, 10, 16);
                    ctx.fillRect(cx - 16, y + 10, 10, 6);
                    ctx.fillRect(cx - 16, y + 8, 4, 8);
                    ctx.fillRect(cx + 6, y + 10, 10, 6);
                    ctx.fillRect(cx + 12, y + 8, 4, 8);
                    ctx.fillRect(cx - 8, y + 24, 6, 10);
                    ctx.fillRect(cx + 2, y + 24, 6, 10);
                    break;

                case 'HURT':
                    // 后仰
                    ctx.fillRect(cx - 6, y - 4, 12, 10);
                    ctx.fillRect(cx - 2, y + 6, 6, 12);
                    ctx.fillRect(cx - 12, y + 10, 10, 4);
                    ctx.fillRect(cx + 2, y + 10, 10, 4);
                    ctx.fillRect(cx - 4, y + 18, 4, 8);
                    ctx.fillRect(cx + 2, y + 18, 4, 8);
                    break;

                case 'DIE':
                    // 倒地
                    ctx.fillRect(cx - 8, y + 8, 12, 8);
                    ctx.fillRect(cx - 4, y + 4, 8, 6);
                    ctx.fillRect(cx - 16, y + 10, 8, 4);
                    ctx.fillRect(cx + 8, y + 10, 8, 4);
                    ctx.fillRect(cx - 12, y + 16, 6, 6);
                    ctx.fillRect(cx + 6, y + 16, 6, 6);
                    break;

                default:
                    // 默认姿势
                    ctx.fillRect(cx - 6, y, 12, 10);
                    ctx.fillRect(cx - 3, y + 10, 6, 14);
                    ctx.fillRect(cx - 10, y + 12, 7, 4);
                    ctx.fillRect(cx + 3, y + 12, 7, 4);
                    ctx.fillRect(cx - 6, y + 24, 5, 8);
                    ctx.fillRect(cx + 1, y + 24, 5, 8);
            }

            // 绘制颜色层
            ctx.fillStyle = color;

            switch(pose) {
                case 'IDLE':
                    ctx.fillRect(cx - 4, y + 2, 8, 6);
                    ctx.fillRect(cx - 2, y + 12, 4, 10);
                    ctx.fillRect(cx - 8, y + 14, 4, 3);
                    ctx.fillRect(cx + 4, y + 14, 4, 3);
                    ctx.fillRect(cx - 5, y + 26, 3, 5);
                    ctx.fillRect(cx + 2, y + 26, 3, 5);
                    break;

                case 'RUN':
                    const rOff = Math.sin(this.stateFrame * 0.5) * 4;
                    ctx.fillRect(cx - 4, y + 2 + rOff * 0.3, 8, 6);
                    ctx.fillRect(cx - 2, y + 12 + rOff * 0.3, 4, 8);
                    const aOff = Math.sin(this.stateFrame * 0.8) * 6;
                    ctx.fillRect(cx - 6 + aOff, y + 14, 4, 3);
                    ctx.fillRect(cx + 2 - aOff, y + 14, 4, 3);
                    const lOff = Math.sin(this.stateFrame * 0.8) * 8;
                    ctx.fillRect(cx - 5 - lOff * 0.5, y + 26, 3, 4);
                    ctx.fillRect(cx + 2 + lOff * 0.5, y + 26, 3, 4);
                    break;

                case 'JUMP':
                    ctx.fillRect(cx - 4, y - 2, 8, 6);
                    ctx.fillRect(cx - 3, y + 8, 6, 8);
                    ctx.fillRect(cx - 12, y + 2, 4, 3);
                    ctx.fillRect(cx + 8, y + 2, 4, 3);
                    ctx.fillRect(cx - 6, y + 20, 4, 4);
                    ctx.fillRect(cx + 4, y + 20, 4, 4);
                    break;

                case 'FALL':
                    ctx.fillRect(cx - 4, y - 6, 8, 6);
                    ctx.fillRect(cx - 2, y + 4, 6, 10);
                    ctx.fillRect(cx - 14, y + 6, 8, 3);
                    ctx.fillRect(cx + 6, y + 6, 8, 3);
                    ctx.fillRect(cx - 6, y + 18, 3, 6);
                    ctx.fillRect(cx + 4, y + 18, 3, 6);
                    break;

                case 'ATTACK1':
                case 'ATTACK2':
                case 'ATTACK3':
                    ctx.fillRect(cx - 4, y + 2, 8, 6);
                    ctx.fillRect(cx - 2, y + 12, 4, 10);
                    if (pose === 'ATTACK1') {
                        ctx.fillRect(cx + 7, y + 14, 6, 3);
                    } else if (pose === 'ATTACK2') {
                        ctx.fillRect(cx - 13, y + 13, 6, 3);
                    } else if (pose === 'ATTACK3') {
                        ctx.fillRect(cx + 10, y + 12, 8, 3);
                    }
                    ctx.fillRect(cx - 5, y + 26, 3, 4);
                    ctx.fillRect(cx + 3, y + 26, 3, 4);
                    break;

                case 'DASH':
                    ctx.fillRect(cx - 4, y + 2, 8, 6);
                    ctx.fillRect(cx - 2, y + 12, 4, 10);
                    ctx.fillRect(cx - 7, y + 16, 4, 2);
                    ctx.fillRect(cx + 3, y + 16, 4, 2);
                    ctx.fillRect(cx - 6, y + 26, 3, 4);
                    ctx.fillRect(cx + 4, y + 26, 3, 4);
                    break;

                case 'SKILL':
                    ctx.fillRect(cx - 6, y - 2, 10, 8);
                    ctx.fillRect(cx - 4, y + 10, 8, 12);
                    ctx.fillRect(cx - 14, y + 12, 8, 4);
                    ctx.fillRect(cx + 6, y + 12, 8, 4);
                    ctx.fillRect(cx - 6, y + 26, 4, 6);
                    ctx.fillRect(cx + 3, y + 26, 4, 6);
                    break;

                case 'HURT':
                    ctx.fillRect(cx - 4, y - 2, 8, 6);
                    ctx.fillRect(cx - 1, y + 8, 4, 8);
                    ctx.fillRect(cx - 10, y + 12, 6, 2);
                    ctx.fillRect(cx + 4, y + 12, 6, 2);
                    ctx.fillRect(cx - 3, y + 20, 2, 4);
                    ctx.fillRect(cx + 2, y + 20, 2, 4);
                    break;

                case 'DIE':
                    ctx.fillRect(cx - 6, y + 10, 8, 5);
                    ctx.fillRect(cx - 2, y + 6, 4, 4);
                    ctx.fillRect(cx - 14, y + 12, 5, 2);
                    ctx.fillRect(cx + 9, y + 12, 5, 2);
                    ctx.fillRect(cx - 10, y + 18, 4, 3);
                    ctx.fillRect(cx + 7, y + 18, 4, 3);
                    break;

                default:
                    ctx.fillRect(cx - 4, y + 2, 8, 6);
                    ctx.fillRect(cx - 2, y + 12, 4, 10);
                    ctx.fillRect(cx - 7, y + 14, 4, 2);
                    ctx.fillRect(cx + 4, y + 14, 4, 2);
                    ctx.fillRect(cx - 4, y + 26, 3, 4);
                    ctx.fillRect(cx + 2, y + 26, 3, 4);
            }

            // 眼睛/装饰
            ctx.fillStyle = accentColor;
            if (pose !== 'DIE') {
                const eyeX = cx + (this.direction > 0 ? 2 : -4);
                ctx.fillRect(eyeX, y + 3, 3, 3);
            }
        }
    }

    // ============================================
    // 玩家类
    // ============================================
    class Player extends Entity {
        constructor(x, y) {
            super(x, y, 36, 48);
            this.speed = 4;
            this.jumpPower = 14;
            this.attackDamage = 15;
            this.maxEnergy = 50;
            this.energy = 50;
            this.comboCount = 0;
            this.comboTimer = 0;
            this.canAttack = true;
            this.canDash = true;
            this.dashCooldown = 0;
            this.attackCooldown = 0;
            this.facing = 1;
        }

        update() {
            super.update();

            // 能量恢复
            if (this.energy < this.maxEnergy) {
                this.energy += 0.05;
            }

            // 连击计时器
            if (this.comboTimer > 0) {
                this.comboTimer--;
                if (this.comboTimer === 0) {
                    this.comboCount = 0;
                }
            }

            // 冲刺冷却
            if (this.dashCooldown > 0) this.dashCooldown--;
            if (this.attackCooldown > 0) this.attackCooldown--;

            // 水平移动
            if (this.state !== 'ATTACK1' && this.state !== 'ATTACK2' &&
                this.state !== 'ATTACK3' && this.state !== 'SKILL' && this.state !== 'HURT') {

                this.vx = 0;

                if (keys['ArrowLeft'] || keys['KeyA']) {
                    this.vx = -this.speed;
                    this.facing = -1;
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    this.vx = this.speed;
                    this.facing = 1;
                }

                if (this.vx !== 0) {
                    this.direction = this.vx > 0 ? 1 : -1;
                    if (this.onGround) {
                        this.state = 'RUN';
                    }
                } else if (this.onGround && this.state !== 'JUMP') {
                    this.state = 'IDLE';
                }

                // 跳跃
                if ((keysPressed['KeyK'] || keysPressed['KeyX']) && this.onGround) {
                    this.vy = -this.jumpPower;
                    this.state = 'JUMP';
                    this.onGround = false;
                    playSound('jump');
                }

                // 下落
                if (!this.onGround) {
                    this.state = this.vy < 0 ? 'JUMP' : 'FALL';
                }
            }

            // 攻击
            if ((keysPressed['KeyJ'] || keysPressed['KeyZ']) && this.canAttack && this.attackCooldown === 0) {
                this.performAttack();
            }

            // 必杀技
            if ((keysPressed['KeyL'] || keysPressed['KeyC']) && this.energy >= 30) {
                this.performSkill();
            }

            // 冲刺
            if (keys['Space'] && this.canDash && this.dashCooldown === 0 && this.onGround) {
                this.performDash();
            }

            // 状态机更新
            if (this.state === 'ATTACK1' || this.state === 'ATTACK2') {
                if (this.stateFrame > 15) {
                    this.state = 'IDLE';
                    this.canAttack = true;
                }
            } else if (this.state === 'ATTACK3') {
                if (this.stateFrame > 25) {
                    this.state = 'IDLE';
                    this.canAttack = true;
                }
            } else if (this.state === 'SKILL') {
                if (this.stateFrame > 40) {
                    this.state = 'IDLE';
                    this.canAttack = true;
                }
            } else if (this.state === 'DASH') {
                if (this.stateFrame > 15) {
                    this.state = 'IDLE';
                    this.canDash = true;
                }
            } else if (this.state === 'HURT') {
                if (this.hurtTimer === 0) {
                    this.state = this.vx !== 0 ? 'RUN' : 'IDLE';
                }
            }

            // 物理更新
            this.x += this.vx;
            this.y += this.vy;
            this.applyGravity();

            // 边界限制
            this.x = Math.max(0, Math.min(GAME_WIDTH - this.width, this.x));

            // 冲刺移动
            if (this.state === 'DASH') {
                this.x += this.facing * 8;
            }
        }

        performAttack() {
            this.canAttack = false;
            this.attackCooldown = 20;

            if (this.comboCount === 0) {
                this.state = 'ATTACK1';
                this.stateFrame = 0;
                this.comboCount = 1;
                this.attackDamage = 15;
            } else if (this.comboCount === 1) {
                this.state = 'ATTACK2';
                this.stateFrame = 0;
                this.comboCount = 2;
                this.attackDamage = 18;
            } else if (this.comboCount === 2) {
                this.state = 'ATTACK3';
                this.stateFrame = 0;
                this.comboCount = 0;
                this.attackDamage = 25;
            }

            this.comboTimer = 45;
            playSound('attack');

            // 检测攻击命中
            setTimeout(() => this.checkAttackHit(), 100);
        }

        performDash() {
            this.state = 'DASH';
            this.stateFrame = 0;
            this.canDash = false;
            this.dashCooldown = 40;
            this.invincible = 10;
            playSound('jump');

            // 创建冲刺残影
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    spawnParticles(this.x + this.width/2, this.y + this.height/2, '#ffffff', 3, 2);
                }, i * 30);
            }
        }

        performSkill() {
            this.energy -= 30;
            this.state = 'SKILL';
            this.stateFrame = 0;
            this.canAttack = false;
            playSound('skill');

            // 技能攻击判定
            setTimeout(() => {
                this.checkSkillHit();
            }, 200);
        }

        checkAttackHit() {
            const attackBox = this.getAttackBox();
            if (!attackBox) return;

            enemies.forEach(enemy => {
                if (this.checkCollision(attackBox, enemy.getHurtbox())) {
                    const knockback = this.state === 'ATTACK3' ? 8 : 4;
                    if (enemy.takeDamage(this.attackDamage, this.facing * knockback, -3)) {
                        this.onHitEnemy(enemy, this.attackDamage);
                    }
                }
            });
        }

        checkSkillHit() {
            const skillBox = {
                x: this.facing > 0 ? this.x : this.x - 60,
                y: this.y - 20,
                width: this.width + 60,
                height: this.height + 40
            };

            // 技能特效
            spawnParticles(this.x + this.width/2 + this.facing * 30, this.y + this.height/2, '#29adff', 20, 8);

            enemies.forEach(enemy => {
                if (this.checkCollision(skillBox, enemy.getHurtbox())) {
                    if (enemy.takeDamage(40, this.facing * 12, -5)) {
                        this.onHitEnemy(enemy, 40);
                    }
                }
            });

            // 屏幕震动
            screenShake.intensity = 8;
        }

        onHitEnemy(enemy, damage) {
            playSound('hit');
            hitStop = 4;
            screenShake.intensity = 3;

            // 粒子效果
            spawnParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff0044', 10, 5);

            // 伤害数字
            damageNumbers.push(new DamageNumber(enemy.x + enemy.width/2, enemy.y, damage, combo > 5));

            // 连击
            combo++;
            comboTimer = 60;

            // 能量恢复
            this.energy = Math.min(this.maxEnergy, this.energy + 5);
        }

        checkCollision(box1, box2) {
            return box1.x < box2.x + box2.width &&
                   box1.x + box1.width > box2.x &&
                   box1.y < box2.y + box2.height &&
                   box1.y + box1.height > box2.y;
        }

        getAttackBox() {
            if (this.state !== 'ATTACK1' && this.state !== 'ATTACK2' &&
                this.state !== 'ATTACK3' && this.state !== 'SKILL') return null;

            const offset = this.facing > 0 ? this.width : -30;
            return {
                x: this.x + offset,
                y: this.y + 10,
                width: 30,
                height: 25
            };
        }

        draw() {
            const drawX = this.facing < 0 ? this.x : this.x;

            // 受击闪烁
            if (this.invincible > 0 && Math.floor(this.invincible / 3) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }

            // 绘制火柴人
            this.drawStickman(drawX, this.y, COLORS.hero.body, COLORS.hero.outline, COLORS.hero.accent, this.state);

            ctx.globalAlpha = 1;

            // 能量条（必杀技充能）
            if (this.energy >= 30) {
                ctx.fillStyle = '#29adff';
                ctx.fillRect(this.x, this.y - 8, this.width * (this.energy / this.maxEnergy), 3);
            }
        }
    }

    // ============================================
    // 敌人类
    // ============================================
    class Enemy extends Entity {
        constructor(x, y, type) {
            super(x, y, 36, 48);
            this.type = type;
            this.attackCooldown = 0;
            this.aiTimer = 0;

            switch(type) {
                case 'grunt':
                    this.health = 30;
                    this.damage = 10;
                    this.speed = 1.5;
                    this.color = COLORS.grunt;
                    break;
                case 'ranger':
                    this.health = 20;
                    this.damage = 8;
                    this.speed = 1;
                    this.color = COLORS.ranger;
                    this.attackRange = 200;
                    break;
                case 'brute':
                    this.health = 80;
                    this.damage = 20;
                    this.speed = 0.8;
                    this.color = COLORS.brute;
                    this.width = 44;
                    this.height = 56;
                    break;
                case 'boss':
                    this.health = 200;
                    this.damage = 25;
                    this.speed = 1.2;
                    this.color = COLORS.boss;
                    this.width = 48;
                    this.height = 64;
                    this.phase = 1;
                    break;
            }
            this.maxHealth = this.health;
        }

        update() {
            super.update();
            if (this.attackCooldown > 0) this.attackCooldown--;
            this.aiTimer++;

            if (this.state === 'HURT') {
                if (this.hurtTimer === 0) {
                    this.state = 'IDLE';
                }
                this.x += this.vx;
                this.y += this.vy;
                this.applyGravity();
                return;
            }

            if (this.state === 'DIE') {
                if (this.stateFrame > 30) {
                    this.dead = true;
                }
                this.stateFrame++;
                return;
            }

            // AI行为
            this.runAI();

            // 物理更新
            this.x += this.vx;
            this.y += this.vy;
            this.applyGravity();

            // 状态更新
            if (this.vx !== 0) {
                this.direction = this.vx > 0 ? 1 : -1;
                this.state = this.onGround ? 'RUN' : 'FALL';
            } else if (this.onGround) {
                this.state = 'IDLE';
            }

            // 边界限制
            this.x = Math.max(0, Math.min(GAME_WIDTH - this.width, this.x));
        }

        runAI() {
            if (!player || player.state === 'DIE') return;

            const dist = player.x - this.x;
            const absDist = Math.abs(dist);

            this.vx = 0;

            switch(this.type) {
                case 'grunt':
                    if (absDist < 40 && this.attackCooldown === 0) {
                        this.attack();
                    } else if (absDist > 40 && absDist < 300) {
                        this.vx = dist > 0 ? this.speed : -this.speed;
                        this.direction = dist > 0 ? 1 : -1;
                    }
                    break;

                case 'ranger':
                    if (absDist < this.attackRange && this.attackCooldown === 0) {
                        this.rangedAttack();
                    } else if (absDist >= this.attackRange) {
                        this.vx = dist > 0 ? this.speed : -this.speed;
                        this.direction = dist > 0 ? 1 : -1;
                    } else if (absDist < 100) {
                        // 后退
                        this.vx = dist > 0 ? -this.speed : this.speed;
                        this.direction = dist > 0 ? -1 : 1;
                    }
                    break;

                case 'brute':
                    if (absDist < 50 && this.attackCooldown === 0) {
                        this.heavyAttack();
                    } else if (absDist > 50 && absDist < 250) {
                        this.vx = dist > 0 ? this.speed : -this.speed;
                        this.direction = dist > 0 ? 1 : -1;
                    }
                    break;

                case 'boss':
                    if (this.phase === 1 && this.health < this.maxHealth * 0.5) {
                        this.phase = 2;
                    }

                    if (absDist < 50 && this.attackCooldown === 0) {
                        if (this.phase === 2 && Math.random() > 0.5) {
                            this.bossSpecial();
                        } else {
                            this.attack();
                        }
                    } else if (absDist > 50) {
                        this.vx = dist > 0 ? this.speed : -this.speed;
                        this.direction = dist > 0 ? 1 : -1;
                    }
                    break;
            }
        }

        attack() {
            this.state = 'ATTACK1';
            this.stateFrame = 0;
            this.attackCooldown = 60;

            setTimeout(() => {
                if (this.checkCollision(this.getAttackBox(), player.getHurtbox())) {
                    player.takeDamage(this.damage, this.direction * 5, -3);
                    playSound('hit');
                    spawnParticles(player.x + player.width/2, player.y + player.height/2, '#ff0044', 8, 4);
                    screenShake.intensity = 4;
                }
            }, 150);
        }

        heavyAttack() {
            this.state = 'ATTACK3';
            this.stateFrame = 0;
            this.attackCooldown = 90;
            this.invincible = 20;

            setTimeout(() => {
                if (this.checkCollision(this.getAttackBox(), player.getHurtbox())) {
                    player.takeDamage(this.damage, this.direction * 10, -6);
                    playSound('hit');
                    spawnParticles(player.x + player.width/2, player.y + player.height/2, '#ff0044', 15, 6);
                    screenShake.intensity = 8;
                }
            }, 300);
        }

        rangedAttack() {
            this.attackCooldown = 80;
            projectiles.push(new Projectile(
                this.x + this.width/2,
                this.y + this.height/2,
                this.direction * 6,
                this.damage,
                this.type
            ));
            playSound('attack');
        }

        bossSpecial() {
            this.attackCooldown = 120;
            // 召唤小怪
            if (currentWave < 3) {
                setTimeout(() => {
                    enemies.push(new Enemy(this.x - 50, this.groundY - 48, 'grunt'));
                    enemies.push(new Enemy(this.x + 50, this.groundY - 48, 'grunt'));
                }, 300);
            }
            // 冲击波
            setTimeout(() => {
                for (let i = -2; i <= 2; i++) {
                    projectiles.push(new Projectile(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        this.direction * 5,
                        this.damage * 0.5,
                        'wave'
                    ));
                }
            }, 200);
        }

        checkCollision(box1, box2) {
            if (!box2) return false;
            return box1.x < box2.x + box2.width &&
                   box1.x + box1.width > box2.x &&
                   box1.y < box2.y + box2.height &&
                   box1.y + box1.height > box2.y;
        }

        getAttackBox() {
            const offset = this.direction > 0 ? this.width : -30;
            return {
                x: this.x + offset,
                y: this.y + 10,
                width: 30,
                height: 25
            };
        }

        takeDamage(damage, knockbackX, knockbackY) {
            const result = super.takeDamage(damage, knockbackX, knockbackY);
            if (result && this.health <= 0) {
                playSound('enemyDeath');
                score += this.type === 'boss' ? 500 : (this.type === 'brute' ? 100 : 50);
                spawnParticles(this.x + this.width/2, this.y + this.height/2,
                    this.color.body, 20, 8);
            }
            return result;
        }

        die() {
            this.state = 'DIE';
            this.stateFrame = 0;
        }

        draw() {
            if (this.dead) return;

            // 受击闪烁
            if (this.invincible > 0 && Math.floor(this.invincible / 3) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }

            const drawX = this.direction < 0 ? this.x : this.x;
            this.drawStickman(drawX, this.y, this.color.body, this.color.outline, this.color.accent, this.state);

            // Boss血条
            if (this.type === 'boss') {
                const barWidth = 60;
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x + this.width/2 - barWidth/2, this.y - 15, barWidth, 6);
                ctx.fillStyle = healthPercent > 0.5 ? '#00e436' : (healthPercent > 0.25 ? '#ffae34' : '#ff0044');
                ctx.fillRect(this.x + this.width/2 - barWidth/2 + 1, this.y - 14, (barWidth - 2) * healthPercent, 4);
            }

            ctx.globalAlpha = 1;
        }
    }

    // ============================================
    // 投射物类
    // ============================================
    class Projectile {
        constructor(x, y, vx, damage, type) {
            this.x = x;
            this.y = y;
            this.vx = vx;
            this.damage = damage;
            this.type = type;
            this.width = type === 'wave' ? 20 : 15;
            this.height = type === 'wave' ? 20 : 8;
            this.life = 100;
            this.direction = vx > 0 ? 1 : -1;
        }

        update() {
            this.x += this.vx;
            this.life--;

            if (this.life <= 0) return false;

            // 检测与玩家碰撞
            if (this.checkCollision(this, player.getHurtbox())) {
                player.takeDamage(this.damage, this.direction * 6, -2);
                playSound('hit');
                spawnParticles(this.x, this.y, '#ff0044', 8, 4);
                return false;
            }

            return true;
        }

        checkCollision(proj, box) {
            return proj.x < box.x + box.width &&
                   proj.x + proj.width > box.x &&
                   proj.y < box.y + box.height &&
                   proj.y + proj.height > box.y;
        }

        draw() {
            ctx.fillStyle = this.type === 'wave' ? '#9d4edd' : '#00e436';
            if (this.type === 'wave') {
                // 波浪形
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(this.x - i * 8, this.y - 5 + i * 5, 8, 10);
                }
            } else {
                // 飞刀
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x + this.direction * 10, this.y + 2, 5, 4);
            }
        }
    }

    // ============================================
    // 关卡系统
    // ============================================
    const levels = {
        1: {
            name: '霓虹贫民窟',
            bgColors: ['#1a1c2c', '#2b0f54', '#3a1c5c'],
            groundY: GAME_HEIGHT - 80,
            waves: [
                { enemies: [{type: 'grunt', count: 2}, {type: 'grunt', count: 1}] },
                { enemies: [{type: 'grunt', count: 3}] },
                { enemies: [{type: 'ranger', count: 2}, {type: 'grunt', count: 2}] },
                { enemies: [{type: 'brute', count: 1}, {type: 'grunt', count: 2}] }
            ],
            boss: { type: 'brute', x: GAME_WIDTH - 100 }
        },
        2: {
            name: '荒野列车',
            bgColors: ['#5f574f', '#a05b53', '#feae34'],
            groundY: GAME_HEIGHT - 100,
            waves: [
                { enemies: [{type: 'grunt', count: 2}, {type: 'ranger', count: 1}] },
                { enemies: [{type: 'ranger', count: 2}, {type: 'grunt', count: 2}] },
                { enemies: [{type: 'brute', count: 1}, {type: 'grunt', count: 2}] }
            ],
            boss: { type: 'boss', x: GAME_WIDTH - 100 }
        },
        3: {
            name: '科技实验室',
            bgColors: ['#1d2b53', '#2a3f5f', '#00e436'],
            groundY: GAME_HEIGHT - 80,
            waves: [
                { enemies: [{type: 'ranger', count: 2}, {type: 'grunt', count: 2}] },
                { enemies: [{type: 'brute', count: 1}, {type: 'ranger', count: 2}] },
                { enemies: [{type: 'grunt', count: 3}, {type: 'ranger', count: 2}] }
            ],
            boss: { type: 'boss', x: GAME_WIDTH - 100 }
        }
    };

    // ============================================
    // 游戏变量
    // ============================================
    let player;
    let enemies = [];
    let projectiles = [];
    let waveEnemies = [];
    let cameraX = 0;
    let waveMessageTimer = 0;
    let currentWaveMessage = '';

    // ============================================
    // 背景绘制
    // ============================================
    function drawBackground(level) {
        const bg = levels[level];

        // 天空渐变
        const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        gradient.addColorStop(0, bg.bgColors[0]);
        gradient.addColorStop(0.5, bg.bgColors[1]);
        gradient.addColorStop(1, bg.bgColors[2]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // 远景 - 建筑物剪影
        ctx.fillStyle = bg.bgColors[0];
        const parallax1 = cameraX * 0.2;
        for (let i = -1; i < 5; i++) {
            const x = i * 200 - (parallax1 % 200);
            const heights = [120, 180, 100, 150, 200, 160];
            ctx.fillRect(x, GAME_HEIGHT - heights[i % 6] - 80, 80, heights[i % 6]);
            // 霓虹窗户
            if (level === 1) {
                ctx.fillStyle = Math.random() > 0.7 ? '#ff004d' : '#29adff';
                for (let w = 0; w < 4; w++) {
                    for (let h = 0; h < 6; h++) {
                        if (Math.random() > 0.5) {
                            ctx.fillRect(x + 10 + w * 18, GAME_HEIGHT - heights[i % 6] - 70 + h * 20, 8, 10);
                        }
                    }
                }
                ctx.fillStyle = bg.bgColors[0];
            }
        }

        // 中景 - 装饰
        ctx.fillStyle = bg.bgColors[1];
        const parallax2 = cameraX * 0.5;
        for (let i = -1; i < 6; i++) {
            const x = i * 150 - (parallax2 % 150);
            ctx.fillRect(x, GAME_HEIGHT - 100, 40, 60);
        }

        // 地面
        ctx.fillStyle = COLORS.ground.dark;
        ctx.fillRect(0, bg.groundY, GAME_WIDTH, GAME_HEIGHT - bg.groundY);

        // 地面纹理
        ctx.fillStyle = COLORS.ground.light;
        for (let i = 0; i < GAME_WIDTH; i += 30) {
            ctx.fillRect(i, bg.groundY + 5, 20, 3);
        }
    }

    // ============================================
    // UI绘制
    // ============================================
    function drawUI() {
        if (!player) return;

        // 生命条背景
        ctx.fillStyle = '#333';
        ctx.fillRect(20, 20, 200, 20);

        // 生命条
        const healthPercent = player.health / player.maxHealth;
        const healthGradient = ctx.createLinearGradient(20, 0, 220, 0);
        healthGradient.addColorStop(0, '#00e436');
        healthGradient.addColorStop(1, '#00ff00');
        ctx.fillStyle = healthPercent > 0.3 ? healthGradient : '#ff0044';
        ctx.fillRect(22, 22, 196 * healthPercent, 16);

        // 生命文字
        ctx.fillStyle = '#fff';
        ctx.font = '8px "Press Start 2P"';
        ctx.textAlign = 'left';
        ctx.fillText(`${Math.ceil(player.health)}/${player.maxHealth}`, 25, 34);

        // 能量条
        ctx.fillStyle = '#222';
        ctx.fillRect(20, 45, 150, 10);

        const energyPercent = player.energy / player.maxEnergy;
        ctx.fillStyle = '#29adff';
        ctx.fillRect(22, 47, 146 * energyPercent, 6);

        // 能量文字
        ctx.fillStyle = '#fff';
        ctx.fillText('能量', 180, 53);

        // 连击
        if (combo > 1) {
            ctx.fillStyle = COLORS.ui.combo;
            ctx.font = '16px "Press Start 2P"';
            ctx.textAlign = 'right';
            ctx.fillText(`${combo} COMBO!`, GAME_WIDTH - 20, 35);
        }

        // 波次提示
        if (waveMessageTimer > 0) {
            ctx.globalAlpha = Math.min(1, waveMessageTimer / 30);
            ctx.fillStyle = '#fff';
            ctx.font = '20px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText(currentWaveMessage, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50);
            ctx.globalAlpha = 1;
        }

        // 关卡名称
        ctx.fillStyle = '#fff';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'left';
        ctx.fillText(`关卡 ${currentLevel}: ${levels[currentLevel].name}`, 20, GAME_HEIGHT - 15);

        // 分数
        ctx.textAlign = 'right';
        ctx.fillText(`分数: ${score}`, GAME_WIDTH - 20, GAME_HEIGHT - 15);
    }

    // ============================================
    // 菜单绘制
    // ============================================
    let menuSelection = 0;
    let menuBlink = 0;

    function drawMenu() {
        // 背景
        const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        gradient.addColorStop(0, '#1a1c2c');
        gradient.addColorStop(1, '#2b0f54');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // 像素星星
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 50; i++) {
            const x = (i * 73) % GAME_WIDTH;
            const y = (i * 47) % GAME_HEIGHT;
            const size = (i % 3) + 1;
            const alpha = 0.3 + (Math.sin(Date.now() / 500 + i) + 1) * 0.2;
            ctx.globalAlpha = alpha;
            ctx.fillRect(x, y, size, size);
        }
        ctx.globalAlpha = 1;

        // 标题
        ctx.fillStyle = '#ff9e22';
        ctx.font = '32px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('像素火柴人', GAME_WIDTH / 2, 100);

        ctx.fillStyle = '#29adff';
        ctx.font = '16px "Press Start 2P"';
        ctx.fillText('街头乱斗', GAME_WIDTH / 2, 130);

        // 菜单选项
        const menuItems = ['开始游戏', '操作说明'];
        menuBlink++;

        menuItems.forEach((item, index) => {
            if (index === menuSelection) {
                ctx.fillStyle = (Math.floor(menuBlink / 15) % 2 === 0) ? '#ffd700' : '#ff0044';
                ctx.fillText('▶ ' + item + ' ◀', GAME_WIDTH / 2, 220 + index * 40);
            } else {
                ctx.fillStyle = '#5f574f';
                ctx.fillText(item, GAME_WIDTH / 2, 220 + index * 40);
            }
        });

        // 版本
        ctx.fillStyle = '#3d3d3d';
        ctx.font = '8px "Press Start 2P"';
        ctx.fillText('v1.0.0', GAME_WIDTH / 2, GAME_HEIGHT - 20);
    }

    function drawControlsInfo() {
        // 背景
        const gradient = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
        gradient.addColorStop(0, '#1a1c2c');
        gradient.addColorStop(1, '#2b0f54');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // 标题
        ctx.fillStyle = '#29adff';
        ctx.font = '20px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('操作说明', GAME_WIDTH / 2, 60);

        // 操作说明
        ctx.fillStyle = '#fff';
        ctx.font = '10px "Press Start 2P"';
        ctx.textAlign = 'left';

        const controls = [
            { key: 'WASD / 方向键', action: '移动' },
            { key: 'J / Z', action: '攻击' },
            { key: 'K / X', action: '跳跃' },
            { key: '空格', action: '冲刺' },
            { key: 'L / C', action: '必杀技' },
            { key: 'ESC', action: '暂停' }
        ];

        controls.forEach((ctrl, index) => {
            ctx.fillStyle = '#ff9e22';
            ctx.fillText(ctrl.key, 150, 120 + index * 35);
            ctx.fillStyle = '#fff';
            ctx.fillText(': ' + ctrl.action, 350, 120 + index * 35);
        });

        // 返回提示
        ctx.fillStyle = '#5f574f';
        ctx.textAlign = 'center';
        ctx.fillText('按 ESC 返回', GAME_WIDTH / 2, GAME_HEIGHT - 50);
    }

    function drawPauseMenu() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        ctx.fillStyle = '#ffd700';
        ctx.font = '24px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('暂停', GAME_WIDTH / 2, 180);

        const menuItems = ['继续游戏', '重新开始', '返回主菜单'];

        menuItems.forEach((item, index) => {
            if (index === menuSelection) {
                ctx.fillStyle = (Math.floor(menuBlink / 15) % 2 === 0) ? '#00e436' : '#29adff';
                ctx.fillText('▶ ' + item + ' ◀', GAME_WIDTH / 2, 240 + index * 35);
            } else {
                ctx.fillStyle = '#5f574f';
                ctx.fillText(item, GAME_WIDTH / 2, 240 + index * 35);
            }
        });
    }

    function drawGameOver() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        ctx.fillStyle = '#ff0044';
        ctx.font = '32px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('游戏结束', GAME_WIDTH / 2, 160);

        ctx.fillStyle = '#fff';
        ctx.font = '12px "Press Start 2P"';
        ctx.fillText(`最终得分: ${score}`, GAME_WIDTH / 2, 220);
        ctx.fillText(`完成关卡: ${currentLevel}`, GAME_WIDTH / 2, 250);

        ctx.fillStyle = '#5f574f';
        ctx.fillText('按 空格 重新开始', GAME_WIDTH / 2, 320);
    }

    function drawVictory() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        ctx.fillStyle = '#ffd700';
        ctx.font = '32px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('恭喜通关!', GAME_WIDTH / 2, 160);

        ctx.fillStyle = '#00e436';
        ctx.font = '16px "Press Start 2P"';
        ctx.fillText(`最终得分: ${score}`, GAME_WIDTH / 2, 220);

        // 评价
        let grade = 'C';
        if (score >= 1500) grade = 'S';
        else if (score >= 1000) grade = 'A';
        else if (score >= 500) grade = 'B';

        ctx.fillStyle = grade === 'S' ? '#ffd700' : (grade === 'A' ? '#00e436' : (grade === 'B' ? '#29adff' : '#5f574f'));
        ctx.font = '48px "Press Start 2P"';
        ctx.fillText(grade, GAME_WIDTH / 2, 300);

        ctx.fillStyle = '#5f574f';
        ctx.font = '10px "Press Start 2P"';
        ctx.fillText('按 空格 重新开始', GAME_WIDTH / 2, 360);
    }

    // ============================================
    // 游戏逻辑
    // ============================================
    function initGame() {
        player = new Player(100, GAME_HEIGHT - 150);
        enemies = [];
        projectiles = [];
        particles = [];
        damageNumbers = [];
        currentWave = 1;
        waveMessageTimer = 0;
        score = 0;
        combo = 0;

        const level = levels[currentLevel];
        player.groundY = level.groundY;

        showWaveMessage(`第 ${currentWave} 波`);
        startWave();
    }

    function showWaveMessage(msg) {
        currentWaveMessage = msg;
        waveMessageTimer = 90;
        playSound('wave');
    }

    function startWave() {
        const level = levels[currentLevel];
        waveEnemies = [];

        if (currentWave <= level.waves.length) {
            const wave = level.waves[currentWave - 1];
            wave.enemies.forEach(e => {
                for (let i = 0; i < e.count; i++) {
                    waveEnemies.push(e.type);
                }
            });
            spawnWaveEnemies();
        } else if (currentLevel < 3) {
            // Boss战
            const boss = level.boss;
            setTimeout(() => {
                enemies.push(new Enemy(boss.x, player.groundY - boss.height, boss.type));
                showWaveMessage('BOSS 战');
            }, 1000);
        } else {
            // 胜利
            gameState = GameState.VICTORY;
        }
    }

    function spawnWaveEnemies() {
        waveEnemies.forEach((type, index) => {
            setTimeout(() => {
                if (gameState === GameState.PLAYING) {
                    const x = Math.random() > 0.5 ? GAME_WIDTH + 50 : -50;
                    const y = player.groundY - 48;
                    enemies.push(new Enemy(x, y, type));
                }
            }, index * 500);
        });
    }

    function checkWaveComplete() {
        if (enemies.length === 0 && waveEnemies.length === 0 && gameState === GameState.PLAYING) {
            if (currentWave < levels[currentLevel].waves.length) {
                currentWave++;
                showWaveMessage(`第 ${currentWave} 波`);
                setTimeout(() => startWave(), 1500);
            } else if (currentLevel < 3) {
                // 进入下一关
                currentLevel++;
                transitionState = 'out';
                transitionAlpha = 0;

                setTimeout(() => {
                    player.x = 100;
                    player.y = GAME_HEIGHT - 150;
                    player.health = player.maxHealth;
                    player.energy = player.maxEnergy;
                    currentWave = 1;
                    player.groundY = levels[currentLevel].groundY;

                    transitionState = 'in';
                    showWaveMessage(`第 ${currentLevel} 关: ${levels[currentLevel].name}`);
                    setTimeout(() => startWave(), 2000);
                }, 1000);
            } else {
                gameState = GameState.VICTORY;
            }
        }
    }

    // ============================================
    // 主游戏循环
    // ============================================
    let lastTime = 0;

    function gameLoop(timestamp) {
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        // 清空画布
        ctx.save();

        // 屏幕震动
        if (screenShake.intensity > 0) {
            screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
            screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
            screenShake.intensity *= 0.9;
            if (screenShake.intensity < 0.5) screenShake.intensity = 0;
        }
        ctx.translate(screenShake.x, screenShake.y);

        // Hit Stop
        if (hitStop > 0) {
            hitStop--;
            ctx.restore();
            requestAnimationFrame(gameLoop);
            return;
        }

        // 根据游戏状态渲染
        switch(gameState) {
            case GameState.MENU:
                drawMenu();
                break;

            case GameState.PLAYING:
                // 更新
                player.update();

                enemies.forEach(enemy => enemy.update());
                enemies = enemies.filter(e => !e.dead);

                projectiles = projectiles.filter(p => p.update());
                particles = particles.filter(p => p.update());
                damageNumbers = damageNumbers.filter(d => d.update());

                // 连击计时
                if (comboTimer > 0) {
                    comboTimer--;
                } else {
                    combo = 0;
                }

                // 波次消息计时
                if (waveMessageTimer > 0) waveMessageTimer--;

                // 检查波次完成
                checkWaveComplete();

                // 检查玩家死亡
                if (player.health <= 0) {
                    gameState = GameState.GAME_OVER;
                }

                // 绘制
                drawBackground(currentLevel);

                enemies.forEach(enemy => enemy.draw());
                player.draw();
                projectiles.forEach(p => p.draw());
                particles.forEach(p => p.draw());
                damageNumbers.forEach(d => d.draw());

                drawUI();
                break;

            case GameState.PAUSED:
                drawBackground(currentLevel);
                enemies.forEach(enemy => enemy.draw());
                player.draw();
                drawUI();
                drawPauseMenu();
                break;

            case GameState.GAME_OVER:
                drawBackground(currentLevel);
                enemies.forEach(enemy => enemy.draw());
                drawUI();
                drawGameOver();
                break;

            case GameState.VICTORY:
                drawBackground(currentLevel);
                drawVictory();
                break;
        }

        // 过渡效果
        if (transitionState === 'out') {
            transitionAlpha += 0.05;
            if (transitionAlpha >= 1) {
                transitionAlpha = 1;
                transitionState = 'waiting';
            }
        } else if (transitionState === 'in') {
            transitionAlpha -= 0.05;
            if (transitionAlpha <= 0) {
                transitionAlpha = 0;
                transitionState = 'none';
            }
        }

        if (transitionAlpha > 0) {
            ctx.fillStyle = `rgba(0, 0, 0, ${transitionAlpha})`;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        }

        ctx.restore();

        // 菜单闪烁
        menuBlink++;

        requestAnimationFrame(gameLoop);
    }

    // ============================================
    // 输入处理
    // ============================================
    document.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        keysPressed[e.code] = true;

        // 初始化音频
        initAudio();

        switch(gameState) {
            case GameState.MENU:
                if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                    menuSelection = Math.max(0, menuSelection - 1);
                } else if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                    menuSelection = Math.min(1, menuSelection + 1);
                } else if (e.code === 'Space' || e.code === 'Enter') {
                    if (menuSelection === 0) {
                        gameState = GameState.PLAYING;
                        initGame();
                    } else {
                        drawControlsInfo();
                        setTimeout(() => {
                            // 临时显示操作说明
                        }, 100);
                    }
                }
                break;

            case GameState.PLAYING:
                if (e.code === 'Escape') {
                    gameState = GameState.PAUSED;
                    menuSelection = 0;
                }
                break;

            case GameState.PAUSED:
                if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                    menuSelection = Math.max(0, menuSelection - 1);
                } else if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                    menuSelection = Math.min(2, menuSelection + 1);
                } else if (e.code === 'Space' || e.code === 'Enter') {
                    if (menuSelection === 0) {
                        gameState = GameState.PLAYING;
                    } else if (menuSelection === 1) {
                        gameState = GameState.PLAYING;
                        initGame();
                    } else {
                        gameState = GameState.MENU;
                    }
                } else if (e.code === 'Escape') {
                    gameState = GameState.PLAYING;
                }
                break;

            case GameState.GAME_OVER:
            case GameState.VICTORY:
                if (e.code === 'Space') {
                    gameState = GameState.PLAYING;
                    currentLevel = 1;
                    initGame();
                }
                break;
        }

        e.preventDefault();
    });

    document.addEventListener('keyup', (e) => {
        keys[e.code] = false;
        keysPressed[e.code] = false;
    });

    // ============================================
    // 启动游戏
    // ============================================
    requestAnimationFrame(gameLoop);

    </script>

<style>

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
}

.inland-security-footer {
  position: fixed;
  z-index: 10;
  bottom: 0;
  right: 0;
  width: fit-content;
  display: flex;
  justify-content: flex-end;
}

.tooltip-container {
  position: relative;
}

.trigger-content {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  padding: 8px;
  background-color: transparent;
  border-radius: 8px;
  cursor: pointer;
}

.minimax-link {
  display: flex;
  align-items: center;
  cursor: pointer;
  font-weight: 300;
  color: #adadad;
  text-decoration: none;
}

.minimax-link:visited {
  color: #adadad;
}

.minimax-link:hover {
  color: #666666;
}

.tooltip-content {
  position: absolute;
  bottom: 100%;
  right: 0;
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 8px;
  padding-bottom: 16px; /* 8px 内容间距 + 8px 用于鼠标移动的透明区域 */
  font-size: 12px;
  line-height: 17px;
  background-color: #fafafa;
  border-radius: 12px;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  color: #171717;
}

/* 创建透明的连接区域，让鼠标可以平滑移动到 tooltip */
.tooltip-content::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 0;
  right: 0;
  height: 16px;
}

.tooltip-container:hover .tooltip-content {
  display: flex;
}

.info-section {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 12px;
}

.beian-link {
  display: flex;
  align-items: center;
  text-decoration: none;
  color: #171717;
}

.beian-icon {
  width: 14px;
  height: 14px;
  margin-right: 2px;
}

.underline-text {
  color: #171717;
  text-decoration: underline;
}

.underline-text:hover {
  color: #000000;
}

/* 深色模式支持 */
@media (prefers-color-scheme: dark) {
  .trigger-content {
    background-color: transparent;
  }

  .minimax-link,
  .minimax-link:visited {
    color: #666666;
  }

  .minimax-link:hover {
    color: #adadad;
  }

  .tooltip-content {
    background-color: #262626;
    color: #ededed;
  }

  .beian-link,
  .underline-text {
    color: #ededed;
  }

  .underline-text:hover {
    color: #ffffff;
  }
}

</style>
<div class="inland-security-footer">
  <div class="tooltip-container">
    <div class="trigger-content">
      <a href="https://www.minimaxi.com/" target="_blank" rel="noreferrer" class="minimax-link">
        <span>© 2026 MiniMax</span>
      </a>
    </div>
    <div class="tooltip-content">
      <section class="info-section">
        <span>上海稀宇科技有限公司</span>
      </section>

      <section class="info-section">
        <a class="beian-link" href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=31010402010179" target="_blank" rel="noreferrer">
          <img alt="hailuo-beian-icon" src="https://cdn.hailuoai.com/hailuo-video-web/public_assets/223037d3-79fd-4db0-a456-749f38a6a14b.png" class="beian-icon">
          <span class="underline-text">沪公网安备31010402010179号</span>
        </a>
        <a href="https://beian.miit.gov.cn/" target="_blank" rel="noreferrer" class="underline-text">
          沪ICP备2023003282号-38
        </a>
      </section>

      <section class="info-section">
        <span>模型名称：MiniMax</span>
        <span>备案号：Shanghai-MiniMax-202505230046</span>
      </section>

      <section class="info-section">
        <a href="https://agent.minimaxi.com/doc/zh/terms-of-service.html" target="_blank" rel="noreferrer" class="underline-text">
          用户协议
        </a>
        <a href="https://agent.minimaxi.com/doc/zh/privacy-policy.html" target="_blank" rel="noreferrer" class="underline-text">
          隐私政策
        </a>
      </section>
    </div>
  </div>
</div>

</body>
</html>
